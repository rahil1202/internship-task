# Transitions in CSS


## üîß Core idea (short and sharp)

A **transition** animates a property between two states (usually triggered by `:hover`, `:focus`, a class change, or JS).
You describe **what** to animate, **how long**, **how** it should ease, and **when** it should start.

Shorthand:

```css
transition: <property> <duration> <timing-function> <delay>;
/* e.g. */
transition: transform 0.3s ease 0s;
```

Longhand equivalents:

```css
transition-property: transform;
transition-duration: 0.3s;
transition-timing-function: ease;
transition-delay: 0s;
```

---

# ‚úÖ What you *can* and *should* transition

Good choices (fast, smooth, GPU-accelerated when using `transform`/`opacity`):

* `transform` (translate/scale/rotate) ‚Äî *best*
* `opacity` ‚Äî fade ins/outs ‚Äî *best*
* `filter` (blur, brightness) ‚Äî *use carefully*
* `box-shadow` ‚Äî nice but can be heavier
* `color`, `background-color` ‚Äî safe
* `width`/`height` ‚Äî works, but can cause layout (reflows) and be jankier

Avoid animating layout-heavy properties where performance matters:

* `top`, `left`, `margin`, `padding` (these cause reflow/layout)
* `display` cannot be animated (`display` jumps ‚Äî use `opacity` + `visibility`)

---

# üß≠ Timing functions (how the motion *feels*)

* `linear` ‚Äî constant speed
* `ease` ‚Äî slow start, fast middle, slow end (default)
* `ease-in` ‚Äî slow then fast
* `ease-out` ‚Äî fast then slow
* `ease-in-out` ‚Äî slow start/end
* `cubic-bezier(x1, y1, x2, y2)` ‚Äî custom curve (play with it)

Example cubic-bezier "springy": `cubic-bezier(0.68, -0.55, 0.27, 1.55)`

---

# üß™ Example 1 ‚Äî Basic fade + scale (button)

```html
<button class="btn">Hover me</button>

<style>
.btn {
  background: #1e90ff;
  color: white;
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  cursor: pointer;

  transition: transform 240ms cubic-bezier(.2,.8,.2,1), /* smooth pop */
              box-shadow 240ms ease,
              background-color 240ms ease;
  transform-origin: center;
}

.btn:hover {
  transform: translateY(-4px) scale(1.03);
  box-shadow: 0 10px 20px rgba(0,0,0,.12);
  background-color: #1673d6;
}
</style>
```

Why this is nice: `transform` is GPU friendly; pairing with `box-shadow` and color gives satisfying tactile feedback.

---

# üß© Example 2 ‚Äî Fade-in/out with visibility (accessible)

`display` can‚Äôt transition. Use `opacity` + `visibility` to make elements fade while not being focusable:

```html
<button id="toggle">Toggle panel</button>
<div id="panel" class="panel">Hello ‚Äî I fade!</div>

<style>
.panel {
  opacity: 0;
  visibility: hidden;
  transform: translateY(-8px);
  transition: opacity .35s ease, transform .35s ease, visibility .35s;
}
.panel.show {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}
</style>

<script>
document.getElementById('toggle').onclick = () => {
  document.getElementById('panel').classList.toggle('show');
};
</script>
```

Note: `visibility` isn‚Äôt truly animating visually, but toggling it helps with focus and screen-readers. Keep it in sync with `opacity`.

---

# üß† Example 3 ‚Äî Expand/collapse (max-height trick)

Animating `height` from `0` to `auto` is tricky. Use `max-height` (set a safe max) or `scaleY`.

```html
<button id="x">Toggle</button>
<div class="collapsible">Long content‚Ä¶</div>

<style>
.collapsible {
  max-height: 0;
  overflow: hidden;
  transition: max-height .45s cubic-bezier(.4,0,.2,1), padding .3s linear;
  padding: 0 16px; /* collapsed padding reduced with trick below */
}
.collapsible.open {
  max-height: 400px; /* must be >= content height */
  padding: 12px 16px;
}
</style>

<script>
document.getElementById('x').onclick = () =>
  document.querySelector('.collapsible').classList.toggle('open');
</script>
```

Pro tip: compute content height with JS for exactness, or use `scaleY` if slight skew is acceptable.

---

# üîÅ Example 4 ‚Äî Multiple properties and sequencing with delays

Stagger effects using delays or CSS variables:

```html
<ul class="list">
  <li style="--d:0s">One</li>
  <li style="--d:.05s">Two</li>
  <li style="--d:.1s">Three</li>
  <li style="--d:.15s">Four</li>
</ul>

<style>
.list li {
  opacity: 0;
  transform: translateY(10px);
  transition: opacity .36s ease var(--d), transform .36s ease var(--d);
}
.list.show li { /* when parent gains .show (via JS or :hover) */
  opacity: 1;
  transform: translateY(0);
}
</style>
```

This is how staggered lists animate in, like a neat reveal. You can also build the `--d` value via JS in loops.

---

# üß∞ Example 5 ‚Äî Transitionend event (sync JS to end)

Useful for cleaning up state after animation completes.

```html
<div class="box"></div>

<style>
.box { width:100px;height:100px;background:#3498db; transition: transform .5s; }
.box.move { transform: translateX(300px); }
</style>

<script>
const b = document.querySelector('.box');
b.addEventListener('click', () => b.classList.toggle('move'));

b.addEventListener('transitionend', (e) => {
  console.log('transition finished for', e.propertyName);
  // e.target.classList.remove('move') // example cleanup
});
</script>
```

`transitionend` fires per-property; check `e.propertyName` if you care which finished.

---

# üîç Performance tips (don‚Äôt be the janky page)

* Prefer animating `transform` and `opacity`. They‚Äôre compositor-only (GPU-accelerated), avoid layout thrash.
* Avoid animating `width`, `height`, `top`, `left` when doing smooth UI (except for small/simple cases).
* Use `will-change: transform, opacity;` sparingly to hint the browser; don‚Äôt overuse ‚Äî it consumes memory.
* Test on low-end devices ‚Äî what‚Äôs smooth on your dev machine may stutter on a phone.

---

# ‚ôø Accessibility: Reduced motion

Respect `prefers-reduced-motion` so users who dislike motion aren‚Äôt forced to watch it.

```css
@media (prefers-reduced-motion: reduce) {
  * {
    transition: none !important;
    animation: none !important;
  }
}
```

Use this to provide an immediate, minimal-motion experience for those who request it.

---

# üîó Practical patterns and recipes

### Animated underline (nav)

```css
a { color:#111; text-decoration:none; position:relative; }
a::after{
  content:''; position:absolute; left:0; right:0; bottom:-3px; height:2px;
  background:#1e90ff; transform: scaleX(0); transform-origin:left;
  transition: transform .25s ease;
}
a:hover::after { transform: scaleX(1); }
```

### Smooth carousel slide (transform)

Use `transform: translateX(...)` to slide items instead of changing `left`.

### Hover tilt card (mouse move)

Use mouse coordinates, set small `transform: rotateX/rotateY` values, and `transition` for release smoothing.

---

# üß™ Debugging transitions

* If nothing animates, ensure the property actually changes (check computed style).
* `display` cannot be animated ‚Äî use `opacity` + `visibility`.
* If your transition flickers, maybe conflicting CSS rules set different `transition` values; unify them.
* Use browser DevTools (Performance/Timeline) to see paint/layout/repaint cost.

---

# ‚öôÔ∏è Small cookbook (copy-paste examples)

**1. Animated dropdown**

```html
<nav>
  <div class="menu">
    <button id="m">Menu</button>
    <ul class="dropdown">
      <li>One</li><li>Two</li><li>Three</li>
    </ul>
  </div>
</nav>

<style>
.dropdown {
  opacity: 0; transform-origin: top; transform: translateY(-8px) scaleY(.98);
  visibility: hidden;
  transition: opacity .26s ease, transform .26s ease, visibility .26s;
}
.menu.open .dropdown {
  opacity: 1; transform: translateY(0) scaleY(1); visibility: visible;
}
</style>

<script>
document.getElementById('m').onclick = e => {
  e.currentTarget.parentElement.classList.toggle('open');
};
</script>
```

**2. Smooth image gallery hover zoom**

```css
.gallery img { transition: transform .45s cubic-bezier(.2,.7,.2,1); }
.gallery img:hover { transform: scale(1.08); }
```

**3. Staggered card reveal (CSS-only with checkbox hack)**

```html
<input id="go" type="checkbox"><label for="go">Reveal</label>
<section class="grid">
  <article style="--i:0">A</article>
  <article style="--i:1">B</article>
  <article style="--i:2">C</article>
</section>

<style>
.grid article {
  opacity:0; transform: translateY(12px);
  transition: opacity .35s ease calc(var(--i) * 80ms), transform .35s ease calc(var(--i) * 80ms);
}
#go:checked ~ .grid article { opacity:1; transform: translateY(0); }
</style>
```

---

# ‚úÖ Quick checklist when designing transitions

* Is the animated property GPU-friendly? (transform/opacity preferred)
* Does the timing feel natural? (ease/ease-out often good)
* Do you respect `prefers-reduced-motion`?
* Are you animating too many elements at once? Stagger if needed.
* Will it be intuitive for users (not surprising)?

---
