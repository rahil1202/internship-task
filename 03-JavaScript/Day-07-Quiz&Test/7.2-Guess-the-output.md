# Guess the ouptut 

## ðŸ”¥ ** PROBLEM 1 â€” Promise inside async, async inside timeout**

```js
console.log("1");

setTimeout(() => {
  console.log("2");

  async function insideTimeout() {
    console.log("3");
    await null;
    console.log("4");
  }

  insideTimeout();

}, 0);

async function main() {
  console.log("5");
  await Promise.resolve();
  console.log("6");
}

main();

console.log("7");
```

### **OUTPUT**


---

# ðŸ”¥ ** PROBLEM 2 â€” Multiple awaits + multiple promises**

```js
console.log("A");

async function x() {
  console.log("B");
  await Promise.resolve();
  console.log("C");
}

Promise.resolve().then(() => console.log("D"));

x();

console.log("E");

Promise.resolve().then(() => console.log("F"));
```

### **OUTPUT**


---

# ðŸ”¥ ** PROBLEM 3 â€” Promise inside Promise inside timeout**

```js
console.log("1");

setTimeout(() => {
  console.log("2");

  Promise.resolve().then(() => {
    console.log("3");

    Promise.resolve().then(() => {
      console.log("4");
    });

  });

}, 0);

Promise.resolve().then(() => console.log("5"));

console.log("6");
```

### **OUTPUT**


---

# ðŸ”¥ ** PROBLEM 4 â€” Blocking loop with async/await + timers**

```js
console.log("Start");

setTimeout(() => console.log("T1"), 0);

async function run() {
  console.log("Inside");

  await null;

  let start = Date.now();
  while (Date.now() - start < 1000) {} // block

  console.log("After Block");
}

run();

console.log("End");
```

### **OUTPUT**



---

# ðŸ”¥ ** PROBLEM 5 â€” Competing microtasks with nested awaits**

```js
async function a() {
  console.log("1");
  await null;
  console.log("2");
}

async function b() {
  console.log("3");
  await null;
  console.log("4");
}

console.log("0");

a();
b();

console.log("5");
```

### **OUTPUT**


---

# ðŸ”¥ ** PROBLEM 6 â€” Mixed task & microtask priorities**

```js
console.log("X");

setTimeout(() => console.log("Y"), 0);

Promise.resolve().then(() => {
  console.log("Z");
  setTimeout(() => console.log("W"), 0);
});

Promise.resolve().then(() => console.log("Q"));

console.log("R");
```

### **OUTPUT**



---

# ðŸ”¥ ** PROBLEM 7 â€” async recursions**

```js
async function recurse(n) {
  if (n === 0) return console.log("Done");
  console.log("Call", n);
  await null;
  recurse(n - 1);
}

console.log("Start");
recurse(3);
console.log("End");
```

### **OUTPUT**



---

# ðŸ”¥ ** PROBLEM 8 â€” Promise constructor vs Promise .then timing**

```js
console.log("1");

new Promise((res) => {
  console.log("2");
  res();
}).then(() => console.log("3"));

console.log("4");
```

### **OUTPUT**


---

# ðŸ”¥ ** PROBLEM 9 â€” await inside loop vs promise all**

```js
async function slow(n) {
  return new Promise((res) => {
    setTimeout(() => res(n), 1000);
  });
}

async function run() {
  console.log("A");

  [1, 2, 3].forEach(async (n) => {
    console.log("B" + n);
    console.log(await slow(n));
  });

  console.log("C");
}

run();
```

### **OUTPUT**


Because forEach doesn't await anything.

---

# ðŸ”¥ ** PROBLEM 10 â€” The Ultimate One (Everything Combined)**

```js
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(() => console.log("3"));
}, 0);

Promise.resolve().then(() => {
  console.log("4");

  setTimeout(() => console.log("5"), 0);

  return Promise.resolve().then(() => console.log("6"));
});

async function test() {
  console.log("7");
  await null;
  console.log("8");
}

test();

console.log("9");
```

### **OUTPUT**


